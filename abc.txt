# File structure:
# /project_root/
#   config.py
#   main.py
#   platform_utils.py
#   speech_manager.py
#   setup_wizard.py
#   features/
#     browser_manager.py
#     system_manager.py
#     weather_manager.py
#     news_manager.py
#     location_manager.py
#     social_media_manager.py
#     wiki_manager.py
#     screenshot_manager.py

# config.py
import os
from dataclasses import dataclass
from pathlib import Path
import json
import logging
import time

@dataclass
class AssistantConfig:
    """Configuration for the virtual assistant"""
    name: str = "Friday"
    voice_id: str = None
    language: str = "en-US"
    wake_word: str = "friday"
    weather_api_key: str = None
    news_api_key: str = None
    sample_rate: int = 16000
    recording_duration: int = 5
    screenshot_dir: Path = Path.home() / "Screenshots"
    
    @classmethod
    def load_config(cls):
        """Load configuration from environment variables"""
        return cls(
            weather_api_key=os.getenv("WEATHER_API_KEY"),
            news_api_key=os.getenv("NEWS_API_KEY")
        )
# In config.py, add:
def save_to_file(self, filepath=None):
    """Save configuration to JSON file"""
    if filepath is None:
        filepath = Path.home() / ".assistant_config.json"
    
    try:
        with open(filepath, 'w') as f:
            # Convert Path objects to strings
            config_dict = {k: str(v) if isinstance(v, Path) else v 
                          for k, v in self.__dict__.items()}
            json.dump(config_dict, f, indent=2)
        return True
    except Exception as e:
        logging.error(f"Error saving config: {e}")
        return False

@classmethod
def load_from_file(cls, filepath=None):
    """Load configuration from JSON file with environment variable fallback"""
    if filepath is None:
        filepath = Path.home() / ".assistant_config.json"
    
    config = cls()
    
    # Try to load from file
    try:
        if os.path.exists(filepath):
            with open(filepath, 'r') as f:
                data = json.load(f)
                for key, value in data.items():
                    if key == "screenshot_dir":
                        setattr(config, key, Path(value))
                    else:
                        setattr(config, key, value)
            return config
    except Exception as e:
        logging.error(f"Error loading config file: {e}")
    
    # Fall back to environment variables
    return cls.load_config()

# platform_utils.py
import os
import platform
import subprocess
import logging
import winreg
from pathlib import Path
from typing import Dict, Optional, List

class PlatformUtils:
    COMMON_APP_LOCATIONS = {
        "Windows": [
            "C:/Program Files",
            "C:/Program Files (x86)",
            str(Path.home() / "AppData/Local"),
            str(Path.home() / "AppData/Local/Programs"),
            "C:/Windows/System32"
        ],
        "Darwin": [  # macOS
            "/Applications",
            str(Path.home() / "Applications"),
            "/System/Applications"
        ],
        "Linux": [
            "/usr/bin",
            "/usr/local/bin",
            "/opt",
            str(Path.home() / ".local/bin")
        ]
    }

    def __init__(self):
        self.system = platform.system()
        self.app_cache = {}
        self.setup_logging()

    def setup_logging(self):
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            filename='platform_utils.log'
        )

    @property
    def is_windows(self) -> bool:
        return self.system == "Windows"

    @property
    def is_mac(self) -> bool:
        return self.system == "Darwin"

    @property
    def is_linux(self) -> bool:
        return self.system == "Linux"
        
    @classmethod
    def is_windows(cls) -> bool:
        return platform.system() == "Windows"

    def get_default_voice(self) -> str:
        """Get system default voice dynamically"""
        try:
            if self.is_windows:
                return self._get_windows_voices()[0]
            elif self.is_mac:
                return self._get_mac_voices()[0]
            else:
                return self._get_linux_voices()[0]
        except Exception as e:
            logging.error(f"Error getting default voice: {e}")
            return ""

    def _get_windows_voices(self) -> List[str]:
        """Get available Windows voices"""
        voices = []
        if not self.is_windows:
            return [""]
            
        try:
            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, 
                            r"SOFTWARE\Microsoft\Speech\Voices\Tokens") as key:
                i = 0
                while True:
                    try:
                        voice_key = winreg.EnumKey(key, i)
                        voices.append(f"HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Voices\\Tokens\\{voice_key}")
                        i += 1
                    except OSError:  # More general exception than WindowsError
                        break
        except (OSError, PermissionError) as e:
            logging.error(f"Error accessing Windows voice registry: {e}")
            # Fallback to default voice
        return voices or ["HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Speech\\Voices\\Tokens\\TTS_MS_EN-US_ZIRA_11.0"]

    def _get_mac_voices(self) -> List[str]:
        """Get available macOS voices"""
        try:
            result = subprocess.run(['say', '-v', '?'], capture_output=True, text=True)
            voices = [line.split()[0] for line in result.stdout.split('\n') if line]
            return [f"com.apple.speech.synthesis.voice.{voice.lower()}" for voice in voices]
        except Exception as e:
            logging.error(f"Error getting macOS voices: {e}")
            return ["com.apple.speech.synthesis.voice.samantha"]

    def _get_linux_voices(self) -> List[str]:
        """Get available Linux voices"""
        try:
            result = subprocess.run(['espeak', '--voices'], capture_output=True, text=True)
            voices = [line.split()[2] for line in result.stdout.split('\n')[1:] if line]
            return voices
        except Exception as e:
            logging.error(f"Error getting Linux voices: {e}")
            return ["default"]

    def scan_for_applications(self, max_depth=3, timeout=60) -> Dict[str, str]:
        """Dynamically scan for installed applications with timeout"""
        paths = {}
        search_locations = self.COMMON_APP_LOCATIONS.get(self.system, [])
        
        # Start timing
        start_time = time.time()
        
        for location in search_locations:
            if time.time() - start_time > timeout:
                logging.warning(f"Application scan timed out after {timeout} seconds")
                break
                
            self._scan_directory(Path(location), paths, depth=0, max_depth=max_depth)
            
        # Cache the results
        self.app_cache = paths
        return paths

    def _scan_directory(self, directory: Path, paths: Dict[str, str], depth=0, max_depth=3):
        """Recursively scan directory for applications with depth limit"""
        # Don't go too deep
        if depth > max_depth:
            return
            
        try:
            if self.is_windows:
                self._scan_windows_directory(directory, paths)
            elif self.is_mac:
                self._scan_mac_directory(directory, paths)
            else:
                self._scan_linux_directory(directory, paths)
                
            # Scan subdirectories
            if depth < max_depth:
                for subdir in directory.iterdir():
                    if subdir.is_dir():
                        self._scan_directory(subdir, paths, depth + 1, max_depth)
        except PermissionError:
            logging.debug(f"Permission denied: {directory}")
        except Exception as e:
            logging.error(f"Error scanning directory {directory}: {e}")

    def _scan_windows_directory(self, directory: Path, paths: Dict[str, str]):
        """Scan for .exe files on Windows"""
        try:
            for exe_file in directory.rglob("*.exe"):
                if not exe_file.is_file():
                    continue
                app_name = exe_file.stem.lower()
                if app_name not in paths:
                    paths[app_name] = str(exe_file)
        except Exception as e:
            logging.error(f"Error scanning Windows directory: {e}")

    def _scan_mac_directory(self, directory: Path, paths: Dict[str, str]):
        """Scan for .app bundles on macOS"""
        try:
            for app_bundle in directory.rglob("*.app"):
                if not app_bundle.is_dir():
                    continue
                app_name = app_bundle.stem.lower()
                if app_name not in paths:
                    paths[app_name] = str(app_bundle)
        except Exception as e:
            logging.error(f"Error scanning macOS directory: {e}")

    def _scan_linux_directory(self, directory: Path, paths: Dict[str, str]):
        """Scan for executables on Linux"""
        try:
            for file_path in directory.iterdir():
                if file_path.is_file() and os.access(str(file_path), os.X_OK):
                    app_name = file_path.stem.lower()
                    if app_name not in paths:
                        paths[app_name] = str(file_path)
        except Exception as e:
            logging.error(f"Error scanning Linux directory: {e}")

    def find_application(self, app_name: str) -> Optional[str]:
        """Find application path by name"""
        app_name = app_name.lower()
        
        # Check cache first
        if app_name in self.app_cache:
            return self.app_cache[app_name]
            
        # Scan for applications if not in cache
        self.scan_for_applications()
        return self.app_cache.get(app_name)

    def get_installed_apps(self) -> List[str]:
        """Get list of all installed applications"""
        if not self.app_cache:
            self.scan_for_applications()
        return list(self.app_cache.keys())

# speech_manager.py
import pyttsx3
import speech_recognition as sr
from typing import Optional

class SpeechManager:
    def __init__(self, voice_id: str):
        self.engine = pyttsx3.init()
        self.engine.setProperty('voice', voice_id)
        self.recognizer = sr.Recognizer()
        
    def speak(self, text: str):
        """Convert text to speech"""
        self.engine.say(text)
        self.engine.runAndWait()

    def verify_microphone(self) -> bool:
        """Check if microphone is working properly"""
        try:
            with sr.Microphone() as source:
                self.recognizer.adjust_for_ambient_noise(source, duration=1)
                return True
        except Exception as e:
            print(f"Microphone check failed: {e}")
            return False

    def listen(self) -> Optional[str]:
        """Listen for voice input and convert to text"""
        with sr.Microphone() as source:
            print("Listening...")
            audio = self.recognizer.listen(source, timeout=5, phrase_time_limit=5)
            
        try:
            print("Recognizing...")
            query = self.recognizer.recognize_google(audio, language='en-US')
            print(f"User said: {query}")
            return query.lower()
        except Exception as e:
            print(f"Error: {e}")
            return None

# features/browser_manager.py
import webbrowser
import pywhatkit as kit

class BrowserManager:
    @staticmethod
    def open_url(url: str):
        webbrowser.open(url)
        
    @staticmethod
    def search_youtube(query: str):
        kit.playonyt(query)
        
    @staticmethod
    def search_google(query: str):
        webbrowser.open(f"https://www.google.com/search?q={query}")

# features/system_manager.py
import os
import platform
import subprocess

class SystemManager:
    @staticmethod
    def shutdown(confirm=False):
        """Shutdown the computer with confirmation"""
        if not confirm:
            return "Please confirm by saying 'confirm shutdown'"
            
        if platform.system() == "Windows":
            os.system("shutdown /s /t 60")
            return "Shutting down in 60 seconds. To cancel, say 'cancel shutdown'"
        else:
            os.system("sudo shutdown -h +1")
            return "Shutting down in 60 seconds. To cancel, use 'sudo shutdown -c'"

    @staticmethod
    def cancel_shutdown():
        """Cancel a pending shutdown"""
        if platform.system() == "Windows":
            os.system("shutdown /a")
        else:
            os.system("sudo shutdown -c")
        return "Shutdown canceled"
            
    @staticmethod
    def restart():
        if platform.system() == "Windows":
            os.system("shutdown /r /t 5")
        else:
            os.system("sudo shutdown -r now")
            
    @staticmethod
    def sleep():
        if platform.system() == "Windows":
            os.system("rundll32.exe powrprof.dll,SetSuspendState 0,1,0")
        else:
            os.system("pmset sleepnow")
            
    @staticmethod
    def open_app(app_path: str):
        """Open application based on platform with improved handling"""
        try:
            system = platform.system()
            if system == "Windows":
                os.startfile(app_path)
            elif system == "Darwin":  # macOS
                subprocess.call(['open', app_path])
            elif system == "Linux":
                subprocess.call(['xdg-open', app_path])
            else:
                print(f"Unsupported platform: {system}")
        except FileNotFoundError:
            print(f"Application not found: {app_path}")
        except PermissionError:
            print(f"Permission denied when opening: {app_path}")
        except Exception as e:
            print(f"Error opening application: {e}")
            
    @staticmethod
    def close_app(app_name: str):
        """Close application based on platform"""
        if platform.system() == "Windows":
            os.system(f"taskkill /f /im {app_name}")
        else:
            os.system(f"pkill {app_name}")

# features/weather_manager.py
import requests
import logging

class WeatherManager:
    def __init__(self, api_key: str):
        self.api_key = api_key
        
    def get_weather(self, city: str) -> str:
        """Get weather information for a city"""
        if not self.api_key:
            return "Weather functionality is not available (missing API key)"
            
        try:
            url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={self.api_key}&units=metric"
            response = requests.get(url, timeout=5)  # Add timeout
            
            if response.status_code == 401:
                return "Weather API key is invalid"
            elif response.status_code == 404:
                return f"City '{city}' not found"
            elif response.status_code != 200:
                return f"Weather service unavailable (Error {response.status_code})"
                
            data = response.json()
            temp = data['main']['temp']
            desc = data['weather'][0]['description']
            return f"The temperature in {city} is {temp}°C with {desc}"
        except requests.ConnectionError:
            return "Couldn't connect to weather service. Check your internet connection."
        except requests.Timeout:
            return "Weather service request timed out. Please try again later."
        except Exception as e:
            logging.error(f"Error getting weather: {e}")
            return "Sorry, I couldn't fetch the weather information"

# features/news_manager.py
import requests

class NewsManager:
    def __init__(self, api_key: str):
        self.api_key = api_key
        
    def get_news(self) -> list:
        """Get top news headlines"""
        try:
            url = f"https://newsapi.org/v2/top-headlines?sources=techcrunch&apiKey={self.api_key}"
            response = requests.get(url)
            data = response.json()
            
            if response.status_code == 200:
                return [article["title"] for article in data["articles"][:5]]
            return ["Sorry, I couldn't fetch the news"]
        except Exception as e:
            return [f"Error getting news: {e}"]

# features/location_manager.py
import requests

class LocationManager:
    @staticmethod
    def get_location() -> dict:
        """Get current location based on IP"""
        try:
            ip = requests.get('https://api.ipify.org').text
            url = f'https://get.geojs.io/v1/ip/geo/{ip}.json'
            response = requests.get(url)
            data = response.json()
            return {
                'city': data.get('city', 'Unknown'),
                'country': data.get('country', 'Unknown'),
                'region': data.get('region', 'Unknown')
            }
        except Exception as e:
            return {'error': str(e)}

# features/social_media_manager.py
import instaloader

class SocialMediaManager:
    def __init__(self):
        self.insta = instaloader.Instaloader()
        
    def get_instagram_profile(self, username: str) -> str:
        """Return Instagram profile URL"""
        return f"https://www.instagram.com/{username}"
        
    def download_profile_pic(self, username: str) -> bool:
        """Download Instagram profile picture"""
        try:
            self.insta.download_profile(username, profile_pic_only=True)
            return True
        except Exception as e:
            print(f"Error downloading profile picture: {e}")
            return False

# features/wiki_manager.py
import wikipedia

class WikiManager:
    @staticmethod
    def search(query: str, sentences: int = 2) -> str:
        """Search Wikipedia and return summary"""
        try:
            return wikipedia.summary(query, sentences=sentences)
        except Exception as e:
            return f"Error searching Wikipedia: {e}"

# features/screenshot_manager.py
from pathlib import Path
import datetime
import pyautogui

class ScreenshotManager:
    def __init__(self):
        self.screenshot_dir = Path.home() / "Screenshots"
        self.screenshot_dir.mkdir(exist_ok=True)
        
    def take_screenshot(self, name: str = None) -> str:
        """Take screenshot and save with given name or timestamp"""
        try:
            if not name:
                name = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            file_path = self.screenshot_dir / f"{name}.png"
            screenshot = pyautogui.screenshot()
            screenshot.save(str(file_path))
            return str(file_path)
        except Exception as e:
            return f"Error taking screenshot: {e}"


# setup_wizard.py
import os
import json
import platform
import speech_recognition as sr
from pathlib import Path
from typing import Dict, Optional, List, Any
import logging
from config import AssistantConfig
from platform_utils import PlatformUtils

class SetupWizard:
    """Configuration wizard for first-time setup of the virtual assistant."""
    
    def __init__(self):
        """Initialize the setup wizard."""
        self.config = AssistantConfig()
        self.platform_utils = PlatformUtils()
        self.config_file = Path.home() / ".assistant_config.json"
        self.setup_logging()
        
    def setup_logging(self):
        """Configure logging for the setup wizard."""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            filename='setup_wizard.log'
        )
    
    def start_wizard(self):
        """Start the configuration wizard process."""
        print("\n" + "="*60)
        print("    VIRTUAL ASSISTANT SETUP WIZARD")
        print("="*60)
        
        print("\nWelcome to the Virtual Assistant Setup Wizard!")
        print("Let's configure your assistant to suit your needs.\n")
        
        # Check if configuration already exists
        if self.config_file.exists():
            print(f"Configuration file found at {self.config_file}")
            choice = input("Would you like to start with existing settings? (y/n): ").lower()
            if choice == 'y':
                try:
                    self.config = AssistantConfig.load_from_file(self.config_file)
                    print("Existing configuration loaded successfully.")
                except Exception as e:
                    logging.error(f"Error loading existing config: {e}")
                    print("Error loading existing configuration. Starting with defaults.")
                    self.config = AssistantConfig()
        
        # Begin configuration steps
        self.configure_basic_settings()
        self.configure_voice_settings()
        self.configure_api_keys()
        self.configure_directories()
        self.test_configuration()
        self.save_configuration()
        
        print("\n" + "="*60)
        print("    SETUP COMPLETE!")
        print("="*60)
        print(f"\nYour assistant is now configured and ready to use!")
        print(f"Configuration saved to: {self.config_file}")
        print("\nYou can edit these settings later by running this wizard again")
        print("or by manually editing the configuration file.")
        print("\nThank you for setting up your Virtual Assistant!")
        
    def configure_basic_settings(self):
        """Configure basic assistant settings."""
        print("\n" + "-"*40)
        print("BASIC SETTINGS")
        print("-"*40)
        
        # Assistant name
        name = input(f"What would you like to name your assistant? [{self.config.name}]: ")
        if name:
            self.config.name = name
            
        # Wake word
        wake_word = input(f"Set a wake word to activate your assistant [{self.config.wake_word}]: ")
        if wake_word:
            self.config.wake_word = wake_word.lower()
            
        # Language
        print("\nAvailable languages:")
        languages = ["en-US", "en-GB", "fr-FR", "de-DE", "es-ES", "it-IT"]
        for i, lang in enumerate(languages, 1):
            print(f"  {i}. {lang}")
            
        lang_choice = input(f"\nSelect language (1-{len(languages)}) [{languages.index('en-US')+1}]: ")
        if lang_choice and lang_choice.isdigit():
            idx = int(lang_choice) - 1
            if 0 <= idx < len(languages):
                self.config.language = languages[idx]
                
    def configure_voice_settings(self):
        """Configure voice and speech settings."""
        print("\n" + "-"*40)
        print("VOICE SETTINGS")
        print("-"*40)
        
        # Get available voices
        available_voices = self._get_available_voices()
        if available_voices:
            print("\nAvailable system voices:")
            for i, voice in enumerate(available_voices, 1):
                # Extract just the voice name for clarity
                voice_name = voice.split('\\')[-1] if '\\' in voice else voice
                print(f"  {i}. {voice_name}")
                
            voice_choice = input(f"\nSelect voice (1-{len(available_voices)}): ")
            if voice_choice and voice_choice.isdigit():
                idx = int(voice_choice) - 1
                if 0 <= idx < len(available_voices):
                    self.config.voice_id = available_voices[idx]
        else:
            print("No system voices detected. Using system default.")
            self.config.voice_id = self.platform_utils.get_default_voice()
            
        # Configure speech recording duration
        duration = input(f"Set maximum recording duration in seconds [{self.config.recording_duration}]: ")
        if duration and duration.isdigit():
            self.config.recording_duration = int(duration)
            
        # Configure sample rate
        sample_rate = input(f"Set audio sample rate in Hz [{self.config.sample_rate}]: ")
        if sample_rate and sample_rate.isdigit():
            self.config.sample_rate = int(sample_rate)
            
        # Test microphone
        print("\nTesting microphone...")
        mic_status = self._test_microphone()
        if mic_status:
            print("✓ Microphone is working correctly.")
        else:
            print("⚠ Microphone test failed. Please check your audio settings.")
            
    def configure_api_keys(self):
        """Configure API keys for various services."""
        print("\n" + "-"*40)
        print("API SETTINGS")
        print("-"*40)
        
        print("\nAPI keys are needed for certain features like weather and news.")
        print("You can skip this step and add them later.")
        
        # Weather API
        weather_key = input(f"OpenWeatherMap API Key [{self._mask_key(self.config.weather_api_key)}]: ")
        if weather_key:
            self.config.weather_api_key = weather_key
            
        # News API
        news_key = input(f"NewsAPI Key [{self._mask_key(self.config.news_api_key)}]: ")
        if news_key:
            self.config.news_api_key = news_key
            
    def configure_directories(self):
        """Configure directory settings."""
        print("\n" + "-"*40)
        print("DIRECTORY SETTINGS")
        print("-"*40)
        
        # Screenshot directory
        current_dir = str(self.config.screenshot_dir)
        screenshot_dir = input(f"Screenshot directory [{current_dir}]: ")
        if screenshot_dir:
            path = Path(screenshot_dir).expanduser().resolve()
            try:
                path.mkdir(parents=True, exist_ok=True)
                self.config.screenshot_dir = path
                print(f"✓ Screenshot directory set to: {path}")
            except Exception as e:
                logging.error(f"Error creating directory: {e}")
                print(f"⚠ Error setting directory: {e}")
                print(f"Using default directory: {current_dir}")
                
    def test_configuration(self):
        """Test the current configuration."""
        print("\n" + "-"*40)
        print("CONFIGURATION TEST")
        print("-"*40)
        
        tests_passed = 0
        total_tests = 3
        
        # Test 1: Configuration validation
        print("\nValidating configuration...")
        if self._validate_config():
            print("✓ Configuration validation passed.")
            tests_passed += 1
        else:
            print("⚠ Configuration has issues. Check the log for details.")
            
        # Test 2: Directory access
        print("\nTesting directory access...")
        if self._test_directory_access():
            print("✓ Directory access test passed.")
            tests_passed += 1
        else:
            print("⚠ Directory access test failed. Check permissions.")
            
        # Test 3: API key validation (if provided)
        print("\nTesting API keys...")
        api_status = self._test_api_keys()
        if api_status == "pass":
            print("✓ API key test passed.")
            tests_passed += 1
        elif api_status == "skip":
            print("- API key test skipped (no keys provided).")
            total_tests -= 1
        else:
            print("⚠ API key test failed. Keys may be invalid.")
            
        # Summary
        print(f"\nTests completed: {tests_passed}/{total_tests} passed")
        
    def save_configuration(self):
        """Save the configuration to file."""
        try:
            # Convert Path objects to strings
            config_dict = {k: str(v) if isinstance(v, Path) else v 
                          for k, v in self.config.__dict__.items()}
            
            with open(self.config_file, 'w') as f:
                json.dump(config_dict, f, indent=2)
                
            print("\n✓ Configuration saved successfully!")
            
            # Create environment variable guide
            self._create_env_guide()
            
        except Exception as e:
            logging.error(f"Error saving configuration: {e}")
            print(f"\n⚠ Error saving configuration: {e}")
            
    def _get_available_voices(self) -> List[str]:
        """Get list of available system voices."""
        try:
            if self.platform_utils.is_windows:
                return self.platform_utils._get_windows_voices()
            elif self.platform_utils.is_mac:
                return self.platform_utils._get_mac_voices()
            else:
                return self.platform_utils._get_linux_voices()
        except Exception as e:
            logging.error(f"Error getting system voices: {e}")
            return []
            
    def _test_microphone(self) -> bool:
        """Test microphone functionality."""
        try:
            recognizer = sr.Recognizer()
            with sr.Microphone() as source:
                recognizer.adjust_for_ambient_noise(source, duration=1)
                return True
        except Exception as e:
            logging.error(f"Microphone test failed: {e}")
            return False
            
    def _validate_config(self) -> bool:
        """Validate the current configuration."""
        try:
            # Check required fields
            if not self.config.name or not self.config.wake_word:
                logging.error("Missing required configuration fields")
                return False
                
            # Validate numeric values
            if not isinstance(self.config.sample_rate, int) or self.config.sample_rate <= 0:
                logging.error(f"Invalid sample rate: {self.config.sample_rate}")
                return False
                
            if not isinstance(self.config.recording_duration, int) or self.config.recording_duration <= 0:
                logging.error(f"Invalid recording duration: {self.config.recording_duration}")
                return False
                
            return True
        except Exception as e:
            logging.error(f"Configuration validation error: {e}")
            return False
            
    def _test_directory_access(self) -> bool:
        """Test access to configured directories."""
        try:
            # Test screenshot directory
            test_file = self.config.screenshot_dir / ".test_access"
            with open(test_file, 'w') as f:
                f.write("test")
            test_file.unlink()  # Delete the test file
            return True
        except Exception as e:
            logging.error(f"Directory access test failed: {e}")
            return False
            
    def _test_api_keys(self) -> str:
        """Test API keys for validity."""
        if not self.config.weather_api_key and not self.config.news_api_key:
            return "skip"
            
        # TODO: Implement actual API testing
        # For now, just check if keys look valid (non-empty)
        if (self.config.weather_api_key and len(self.config.weather_api_key) < 10) or \
           (self.config.news_api_key and len(self.config.news_api_key) < 10):
            return "fail"
            
        return "pass"
        
    def _mask_key(self, key: Optional[str]) -> str:
        """Mask API key for display."""
        if not key:
            return "(not set)"
        if len(key) <= 8:
            return "*" * len(key)
        return key[:4] + "*" * (len(key) - 8) + key[-4:]
        
    def _create_env_guide(self):
        """Create a guide for setting environment variables."""
        env_file = Path.home() / ".assistant_env_guide.txt"
        
        try:
            with open(env_file, 'w') as f:
                f.write("# Virtual Assistant Environment Variables\n")
                f.write("# You can set these variables in your environment to override config file values\n\n")
                
                if platform.system() == "Windows":
                    f.write("# Windows (Command Prompt)\n")
                    f.write("set WEATHER_API_KEY=your_key_here\n")
                    f.write("set NEWS_API_KEY=your_key_here\n\n")
                    
                    f.write("# Windows (PowerShell)\n")
                    f.write("$env:WEATHER_API_KEY=\"your_key_here\"\n")
                    f.write("$env:NEWS_API_KEY=\"your_key_here\"\n\n")
                else:
                    f.write("# Linux/macOS (Bash/Zsh)\n")
                    f.write("export WEATHER_API_KEY=your_key_here\n")
                    f.write("export NEWS_API_KEY=your_key_here\n\n")
                    
                f.write("# To make these permanent, add them to your shell profile file\n")
                f.write("# (.bashrc, .zshrc, etc.)\n")
                
            print(f"\nEnvironment variable guide created at: {env_file}")
            
        except Exception as e:
            logging.error(f"Error creating environment guide: {e}")

if __name__ == "__main__":
    wizard = SetupWizard()
    wizard.start_wizard()

import os
import random
import json
import logging
import datetime
import time
from typing import Optional
from pathlib import Path
import argparse

# Local imports
from config import AssistantConfig
from platform_utils import PlatformUtils
from speech_manager import SpeechManager
from features.browser_manager import BrowserManager
from features.system_manager import SystemManager
from features.weather_manager import WeatherManager
from features.news_manager import NewsManager
from features.location_manager import LocationManager
from features.social_media_manager import SocialMediaManager
from features.wiki_manager import WikiManager
from features.screenshot_manager import ScreenshotManager

# Optional imports with error handling
try:
    from transformers import pipeline
    NLP_AVAILABLE = True
except ImportError:
    NLP_AVAILABLE = False
    print("Transformers package not installed. NLP features will be limited.")

class VirtualAssistant:
    def __init__(self):
        # Check if this is the first run
        config_file = Path.home() / ".assistant_config.json"
        if not config_file.exists():
            print("First-time setup detected. Starting configuration wizard...")
            from setup_wizard import SetupWizard
            wizard = SetupWizard()
            wizard.start_wizard()
        
        # Check dependencies first
        self.missing_deps, self.optional_missing = self.check_dependencies()
        if self.missing_deps:
            print(f"WARNING: Missing required dependencies: {', '.join(self.missing_deps)}")
            print("Some features will not be available.")
            print("Install with: pip install " + " ".join(self.missing_deps))
            
        if self.optional_missing:
            print(f"NOTE: Missing optional dependencies: {', '.join(self.optional_missing)}")
            print("Advanced features will be limited.")
        
        # Set NLP availability flag based on dependency check
        self.NLP_AVAILABLE = "transformers" not in self.optional_missing
        
        # Core initialization
        self.config = AssistantConfig.load_config()
        self.platform_utils = PlatformUtils()
        self.config.voice_id = self.platform_utils.get_default_voice()
        self.speech = SpeechManager(self.config.voice_id)
        self.browser = BrowserManager()
        self.system = SystemManager()
        
        # Feature managers - initialize only if dependencies available
        if "pywhatkit" not in self.missing_deps:
            self.weather = WeatherManager(self.config.weather_api_key)
            self.news = NewsManager(self.config.news_api_key)
        
        if "pyautogui" not in self.missing_deps:
            self.screenshot = ScreenshotManager()
            
        if "instaloader" not in self.missing_deps:
            self.social = SocialMediaManager()
            
        if "wikipedia" not in self.missing_deps:
            self.wiki = WikiManager()
            
        self.location = LocationManager()
        
        # App detection
        self.app_paths = self.platform_utils.get_installed_apps()
        
        # Enhanced features
        self.setup_logging()
        self.load_personality()
        self.conversation_history = []
        self.max_history_length = 10
        self.user_preferences = {}
        self.load_user_preferences()

        # Initialize NLP features as None for lazy loading
        self.sentiment_analyzer = None
        self.intent_classifier = None
        
    def check_dependencies(self):
        """Check if all required dependencies are installed"""
        missing_deps = []
        
        # Core dependencies
        try:
            import pyttsx3
        except ImportError:
            missing_deps.append("pyttsx3")
        
        try:
            import speech_recognition
        except ImportError:
            missing_deps.append("speech_recognition")
        
        # Feature dependencies
        try:
            import pywhatkit
        except ImportError:
            missing_deps.append("pywhatkit")
        
        try:
            import pyautogui
        except ImportError:
            missing_deps.append("pyautogui")
        
        try:
            import instaloader
        except ImportError:
            missing_deps.append("instaloader")
        
        try:
            import wikipedia
        except ImportError:
            missing_deps.append("wikipedia")
        
        # Optional dependencies
        optional_deps = []
        try:
            import transformers
        except ImportError:
            optional_deps.append("transformers")
        
        return missing_deps, optional_deps

    def wish_user(self):
        """Greet user based on time of day"""
        hour = datetime.datetime.now().hour
        time_str = time.strftime("%I:%M %p")
        
        if 0 <= hour < 12:
            greeting = f"Good Morning! It's {time_str}"
        elif 12 <= hour < 16:
            greeting = f"Good Afternoon! It's {time_str}"
        elif 16 <= hour < 20:
            greeting = f"Good Evening! It's {time_str}"
        else:
            greeting = f"Hello! It's {time_str}"
            
        self.speech.speak(f"{greeting}. I am {self.config.name}, how may I assist you?")

    def process_command(self, command: str) -> bool:
        """Process user command with improved validation"""
        # Basic validation
        if not command or not isinstance(command, str):
            return True
            
        # Sanitize input (allow URL characters and other safe special chars)
        command = command.lower().strip()
        
        # Only block potentially dangerous characters
        dangerous_chars = set('`$(){}[]&|;\\')
        if any(c in dangerous_chars for c in command):
            self.speech.speak("I'm sorry, that command contains characters I can't process.")
            return True
            
        # Update conversation history
        self.update_conversation_history(command, "user")
            
        # Basic commands
        if "goodbye" in command or "bye" in command:
            self.speech.speak("Goodbye! Have a great day!")
            return False
            
        # Browser commands
        elif "open youtube" in command:
            if hasattr(self, 'browser'):
                self.browser.open_url("youtube.com")
            else:
                self.speech.speak("I'm sorry, browser features are unavailable due to missing dependencies.")
        elif "play" in command:
            if "pywhatkit" not in self.missing_deps:
                query = command.replace("play", "").strip()
                self.browser.search_youtube(query)
            else:
                self.speech.speak("I'm sorry, YouTube features are unavailable due to missing dependencies.")
        elif "search" in command and "google" in command:
            if hasattr(self, 'browser'):
                query = command.replace("search", "").replace("google", "").strip()
                self.browser.search_google(query)
            else:
                self.speech.speak("I'm sorry, browser features are unavailable due to missing dependencies.")
            
        # System commands
        if "shutdown" in command:
            if hasattr(self, 'system'):
                if "confirm shutdown" in command:
                    response = self.system.shutdown(confirm=True)
                else:
                    response = self.system.shutdown(confirm=False)
                    self.speech.speak(response)
            else:
                self.speech.speak("System commands are unavailable due to missing dependencies.")
        elif "cancel shutdown" in command:
            if hasattr(self, 'system'):
                response = self.system.cancel_shutdown()
                self.speech.speak(response)
            else:
                self.speech.speak("System commands are unavailable due to missing dependencies.")
        elif "restart" in command:
            if hasattr(self, 'system'):
                self.system.restart()
            else:
                self.speech.speak("System commands are unavailable due to missing dependencies.")
        elif "sleep" in command:
            if hasattr(self, 'system'):
                self.system.sleep()
            else:
                self.speech.speak("System commands are unavailable due to missing dependencies.")
            
        # Application commands
        elif "notepad" in command or "text editor" in command:
            if hasattr(self, 'platform_utils') and hasattr(self, 'system'):
                app_path = self.platform_utils.find_application("notepad" if self.platform_utils.is_windows else "textedit")
                if app_path:
                    self.system.open_app(app_path)
            else:
                self.speech.speak("Application commands are unavailable due to missing dependencies.")
                
        # Weather commands
        elif "weather" in command:
            if hasattr(self, 'weather'):
                city = "London"  # Default city, can be extracted from command
                result = self.weather.get_weather(city)
                self.speech.speak(result)
            else:
                self.speech.speak("Weather features are unavailable due to missing dependencies.")
            
        # News commands
        elif "news" in command:
            if hasattr(self, 'news'):
                self.speech.speak("Here are today's top headlines:")
                for i, headline in enumerate(self.news.get_news(), 1):
                    self.speech.speak(f"Headline {i}: {headline}")
            else:
                self.speech.speak("News features are unavailable due to missing dependencies.")
                
        # Location commands
        elif "where am i" in command:
            if hasattr(self, 'location'):
                location = self.location.get_location()
                self.speech.speak(
                    f"You are in {location['city']}, {location['region']}, {location['country']}"
                )
            else:
                self.speech.speak("Location features are unavailable due to missing dependencies.")
                
        # Wikipedia commands
        elif "wikipedia" in command:
            if hasattr(self, 'wiki'):
                query = command.replace("wikipedia", "").strip()
                result = self.wiki.search(query)
                self.speech.speak("According to Wikipedia")
                self.speech.speak(result)
            else:
                self.speech.speak("Wikipedia features are unavailable due to missing dependencies.")
                
        # Screenshot commands
        elif "screenshot" in command or "take ss" in command:
            if hasattr(self, 'screenshot'):
                self.speech.speak("Taking screenshot")
                path = self.screenshot.take_screenshot()
                self.speech.speak(f"Screenshot saved to {path}")
            else:
                self.speech.speak("Screenshot features are unavailable due to missing dependencies.")
        
        # If no specific command matched, try to generate a response
        else:
            response = self.generate_response(command)
            self.speech.speak(response)
            
        return True

    def setup_logging(self):
        """Configure logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            filename=f'{self.config.name.lower()}_ai.log'
        )

    def load_personality(self):
        """Load personality traits and responses"""
        self.personality = {
            "traits": {
                "friendliness": 0.8,
                "formality": 0.5,
                "humor": 0.6
            },
            "responses": {
                "greeting": [
                    f"Hello! I'm {self.config.name}. How can I assist you today?",
                    f"Hi there! {self.config.name} at your service!",
                    "Greetings! How may I help you?"
                ],
                "farewell": [
                    "Goodbye! It was a pleasure chatting with you.",
                    "Take care! Feel free to come back anytime.",
                    "Until next time! Have a great day!"
                ],
                "confusion": [
                    "I'm not quite sure I understood that. Could you rephrase?",
                    "Could you explain that differently?",
                    "I'm still learning, could you clarify?"
                ]
            }
        }

    def save_user_preferences(self):
        """Save user preferences to file"""
        try:
            with open(f'{self.config.name.lower()}_preferences.json', 'w') as f:
                json.dump(self.user_preferences, f)
        except Exception as e:
            logging.error(f"Error saving preferences: {e}")

    def load_user_preferences(self):
        """Load user preferences from file"""
        try:
            if os.path.exists(f'{self.config.name.lower()}_preferences.json'):
                with open(f'{self.config.name.lower()}_preferences.json', 'r') as f:
                    self.user_preferences = json.load(f)
        except Exception as e:
            logging.error(f"Error loading preferences: {e}")

    def update_conversation_history(self, text, speaker):
        """Update conversation history"""
        self.conversation_history.append({
            'text': text,
            'speaker': speaker,
            'timestamp': datetime.datetime.now().isoformat()
        })
        
        # Maintain max history length
        if len(self.conversation_history) > self.max_history_length:
            self.conversation_history.pop(0)

    def _ensure_nlp_loaded(self):
        """Lazy load NLP models when first needed"""
        if not self.NLP_AVAILABLE:
            # Create simple fallback functions
            self.sentiment_analyzer = lambda text: [{"label": "NEUTRAL", "score": 0.5}]
            self.intent_classifier = lambda text, labels: {"labels": labels, "scores": [0.5] * len(labels)}
            return

        if self.sentiment_analyzer is None:
            try:
                from transformers import pipeline
                self.sentiment_analyzer = pipeline("sentiment-analysis", 
                                          model="distilbert-base-uncased-finetuned-sst-2-english")
                self.intent_classifier = pipeline("zero-shot-classification")
                logging.info("NLP models loaded successfully")
            except Exception as e:
                logging.error(f"NLP setup error: {e}")
                # Create simple fallback functions
                self.sentiment_analyzer = lambda text: [{"label": "NEUTRAL", "score": 0.5}]
                self.intent_classifier = lambda text, labels: {"labels": labels, "scores": [0.5] * len(labels)}

    def analyze_sentiment(self, text):
        """Analyze sentiment with lazy loading"""
        self._ensure_nlp_loaded()
        try:
            return self.sentiment_analyzer(text)[0]
        except Exception as e:
            logging.error(f"Sentiment analysis error: {e}")
            return {"label": "NEUTRAL", "score": 0.5}

    def classify_intent(self, text, labels):
        """Classify intent with lazy loading"""
        self._ensure_nlp_loaded()
        try:
            return self.intent_classifier(text, candidate_labels=labels)
        except Exception as e:
            logging.error(f"Intent classification error: {e}")
            return {"labels": labels, "scores": [0.5] * len(labels)}

    def generate_response(self, command):
        """Generate a response to the user's command"""
        # Simple responses based on keywords
        if "hello" in command:
            return random.choice(self.personality["responses"]["greeting"])
        elif "bye" in command:
            return random.choice(self.personality["responses"]["farewell"])
        else:
            return random.choice(self.personality["responses"]["confusion"])

    def run(self):
        """Start the assistant"""
        self.wish_user()
        
        running = True
        while running:
            user_command = input("You: ")
            running = self.process_command(user_command)

if __name__ == "__main__":
    # Add command-line argument parsing for setup
    parser = argparse.ArgumentParser(description="Virtual Assistant")
    parser.add_argument('--setup', action='store_true', help="Run the setup wizard")
    args = parser.parse_args()

    if args.setup:
        from setup_wizard import SetupWizard
        wizard = SetupWizard()
        wizard.start_wizard()
    else:
        assistant = VirtualAssistant()
        assistant.run()
